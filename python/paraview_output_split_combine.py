# Script to take the input of vtu files generated by aspect, and output graphs from the data

# This example specifically looks at plotting temperature against time
# It then looks at the temperature of the upper mantle in the left and right side of the model 
# and returns the steady state temperature for each side of the model as a excel spreadsheet

# Satoshi Purkiss Jan 2024

import os
import vtuIO
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

def find_index(gradient):
    # Iterate through the gradient array
    for i in range(25, len(gradient)):
        # Check if the magnitude of the previous three values is less than 15
        if np.all(np.abs(gradient[i-3:i]) < 15):
            # print("gradient used")
            return i -3  # Return the index of the first of these three values

    return 25  # Return Value if no such index is found

def process_vtu_files(input_folder, timestep,top_depth,bottom_depth):
    # Iterate over all VTU files in the input folder
    # Create an empty list to store rows
    rows = []

    # convert depth ranges from km to m
    top_depth = top_depth*1000
    bottom_depth = bottom_depth*1000
    n = 0
    for filename in os.listdir(input_folder):
        
        if filename.endswith('.vtu'):
            file_path = os.path.join(input_folder, filename)

            vtufile = vtuIO.VTUIO(file_path,dim=2)

            # Split the table into L and R based on the criteria
            upper_mantle = (vtufile.points[:, 1] <= vtufile.points[:, 1].max() - top_depth) & (vtufile.points[:, 1] >= vtufile.points[:, 1].max() - bottom_depth)
            condition = (vtufile.points[:, 0] <= (2 * vtufile.points[:, 0].max()) / 3) 

            # # Calculate the average of X for L and R
            avg_T_L = vtufile.get_point_field('T')[condition & upper_mantle].mean()
            avg_T_R = vtufile.get_point_field('T')[~condition & upper_mantle].mean()

            # Append the row to the list
            rows.append([
                n*timestep,
                avg_T_L,
                avg_T_R
            ])
            n += 1

    return np.array(rows)

def plot_and_save(df, input_folder_path, name,top_depth,bottom_depth):
    # Extract x axis from the first column
    x_axis = df[:, 0]/1e6 # converting from years to million years
    y_axes = df[:, 1:]

    # Plot each y axis over the x axis
    average_n = []
    fig, ax1 = plt.subplots()
    for column in range(y_axes.shape[1]):
        label = ["Oceanic", "Continental"][column % 2]  
        label_colour = ["b", "orange"][column % 2]  
        ax1.plot(x_axis, y_axes[:, column], label=label)

        index = find_index(np.gradient(y_axes[:, column]))
        average = np.mean(y_axes[index:, column])
        average_n.append(average)
        # print("{}: Average is {}".format(label, average))
        ax1.axvline(x_axis[index],label=f"{label} Steady State Start",color=label_colour,linestyle="--")

    # Add labels and legend
    ax1.set_xlabel("Time (Million Years)")
    ax1.set_ylabel('Temperature (K)')
    ax1.set_ylim(500, 2500)

    ax1.spines["top"].set_visible(False)
    ax1.spines["right"].set_visible(False)
    # ax1.set_title(name)
    plt.legend(loc='upper left')

    # Save the plot to the specified folder
    outputfilepath = input_folder_path + name + f'_{top_depth}-{bottom_depth}km_plot.png'
    plt.tight_layout()
    plt.savefig(outputfilepath, format='png',dpi=300)
    # plt.show()
    plt.close()  # Clear the current figure
    return average_n

def plot_and_save_cum_r(df, output_folder_path, name,top_depth,bottom_depth):
    # Extract x axis from the first column
    x_axis = df[:, 0]/1e6 # Converting to million years from years
    y_axis = df[:, 2]  # Plotting only the R data

    fig, ax2 = plt.subplots()
    ax2.plot(x_axis, y_axis, label=name)

    index = find_index(np.gradient(y_axis))
    average = np.mean(y_axis[index:]) 
    # print("R: Average is {}".format(average))

    # plt.axvline(x_axis[index],linestyle="--",label="Steady State Start")
    ax2.set_xlabel("Time (Million Years)")
    ax2.set_ylabel('Temperature (K)')
    ax2.set_ylim(1000, 2500)
    # ax2.set_legend()
    # ax2.set_title(f"Cumulative of all RHS's of model for {top_depth}-{bottom_depth}km depth")
    ax2.spines["top"].set_visible(False)
    ax2.spines["right"].set_visible(False)

    outputfilepath = output_folder_path+'left_conv_cumulative_R_plot.png'
    plt.savefig(outputfilepath, format='png',dpi=300)

    return [average]  # Return as a list for consistency with the other function

def write_data_to_excel(filename, data):
    # Convert the data to a pandas DataFrame
    df = pd.DataFrame(data, columns=['Folder Name', 'Average L', 'Average R'])

    # Write the DataFrame to an Excel file
    with pd.ExcelWriter(filename, engine='openpyxl') as writer:
        df.to_excel(writer, index=False, sheet_name='Sheet1')

    print(f"Data written to {filename}")

def main():
    timestep = 20000000
    main_folder_path = r"C:\Users\satos\OneDrive - Durham University\Documents\UniStuff\Year 3\Diss\model outputs\v5"
    output_folder_path = r"C:\Users\satos\OneDrive - Durham University\Documents\UniStuff\Year 3\Diss\vtu_handler_outputs\third_split\v5\100-200_big_T_range\\"#remember \\ on the end

    all_data = []

    # define the range of depths that will be plot 
    top_depth = 100    #km
    bottom_depth = 200 #km

    # Iterate over each subfolder in the main folder
    for name in os.listdir(main_folder_path):
        subfolder_path = os.path.join(main_folder_path, name, 'solution')
        if os.path.isdir(subfolder_path):
            print('Working on {}-{}km depth in {}'.format(top_depth,bottom_depth,name))
            df = process_vtu_files(subfolder_path, timestep,top_depth,bottom_depth)
            average_n = plot_and_save(df, output_folder_path, name,top_depth,bottom_depth)
            # Append the folder name and averages to the list
            all_data.append([name, average_n[0], average_n[1]])   # for plotting both L and R

            # Plot cumulative graph of only right hand side values
            # plot_and_save_cum_r(df, output_folder_path, name,top_depth,bottom_depth)

    # Write all data to a single Excel file at the end
    final_excel_filename = os.path.join(output_folder_path, "summary.xlsx")
    write_data_to_excel(final_excel_filename, all_data)

if __name__ == "__main__":
    main()